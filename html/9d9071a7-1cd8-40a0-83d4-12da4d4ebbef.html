<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
        <title>PleaseUnlockIT</title>
    </head>
    <body>
        <!-- header-bg -->
        <style type="text/css">
            .badge, .badge-timer {
            background-color: #F6F5F2;
            border-radius: .2rem;
            }
            .crypto-amount {
            padding: .1rem;
            border-radius: .3rem;
            background-color: #F6F5F2;
            }
            .qrcode {
            width: 100%;
            text-align: center;
            }
            canvas {
            background-color: #fff;
            border-radius: .3rem;
            padding: 1rem;
            }
            .info {
            padding: 1rem;
            background-color: #F6F5F2;
            border-radius: .4rem;
            }
        </style>
        <div class="wrapper" style="padding-top: 2rem !important">
            <div class="container-fluid">
                <!-- START ROW -->
                    <div class="card m-b-30">
                        <div class="card-body">
                            <h4>
                            <b>QUESTION:</b>
                            <br>
                            </h4>
                            <div class="mb-0" id="info">
                            <div class="row">
                                <div class="col-md-9">
                                    <p>Chris recently received an array&nbsp;ğ‘p&nbsp;as his birthday
gift from Joseph, whose elements are either 0 or 1. He wants to use
it to generate an infinite long superarray. Here is his strategy:
each time, he inverts his array by bits, changing all 0 to 1 and
all 1 to 0 to get another array, then concatenate the original
array and the inverted array together. For example, if the original
array is&nbsp;[0,1,1,0][0,1,1,0], then the inverted array will
be&nbsp;[1,0,0,1][1,0,0,1]&nbsp;and the new array will
be&nbsp;[0,1,1,0,1,0,0,1][0,1,1,0,1,0,0,1]. He wonders what the
array will look like after he repeat this many many times.</p>
<p>He ask you to help him sort this out. Given the original
array&nbsp;ğ‘p&nbsp;of length&nbsp;ğ‘›n&nbsp;and two
indices&nbsp;ğ‘,ğ‘a,b&nbsp;(ğ‘›â‰ªğ‘â‰ªğ‘,â‰ª(nâ‰ªaâ‰ªb,â‰ª&nbsp;means much less
than) Design an algorithm to calculate the sum of elements
between&nbsp;ğ‘a&nbsp;and&nbsp;ğ‘b&nbsp;of the generated infinite
array&nbsp;ğ‘Ì‚&nbsp;p^, specifically,&nbsp;âˆ‘ğ‘â‰¤ğ‘–â‰¤ğ‘ğ‘ğ‘–^âˆ‘aâ‰¤iâ‰¤bpi^. He
also wants you to do it real fast, so make sure your algorithm runs
less than&nbsp;ğ‘‚(ğ‘)O(b)&nbsp;time. Explain your algorithm and
analyze its complexity.</p>
<p>&nbsp;</p>
<p><img alt="7. Chris recently received an array p as his birthday gift from Joseph, whose elements are either 0 or 1. He wants
to use it " src="https://media.cheggcdn.com/media/7ee/7ee88ede-eaf4-4fb7-85a8-c38ac0981ecd/phpwvJ0jB" style="height:315px;"></p>

                                </div>

                            </div>
                            </div>
                            <div class="mt-3 invoice-card">

                            <div id="details" class="mt-4 info">
                                <h4>
                                    <b>ANSWER:</b>
                                    <br>
                                </h4>
                                <div class="row">
                                    <div class="col">
                                        <p>Let denote Input Array as P and reverse of this as R. Now, lets examine the pattern for different values of number of times the operations are performed.</p> <p>N=1 - P. N=2- PR. N=3- PRRP. N=4 - PRRPRPPR. N=5 - PRRPRPPRRPPRPRRP.</p> <p>From the pattern, we can see that every block of 4 elements(P&nbsp;or R) has 2 Ps and 2Rs.</p> <p>Now We know the number of 0s and 1s in in given array. So to caluclate the sum of digits between a and b, we will devide the subarray from intex a to index b in sections as describe below :</p> <p>Block B1 = Starts from a. Ends at first ocuurence after a where (index%(4*n)=0). Let this index be j.</p> <p>Block B2= Starts from j, Ends at first ocuurence before b, where (index%(4*n)=0), Let this index be k.</p> <p>Block B3=&nbsp;Starts from k. Ends at b.</p> <p>We will iterate for blocks B1 and B3 to find number of 1s. Complexity will be O(n)</p> <p>For block B2, number of 1s=(k-j)*n*(Number of 1s in original number i.e P). Complexity will be O(1).</p> <p>Now Sum of elements from a to b= Sum of 1s in B1,B2 and B3, which we already have calculated.</p> <p>Overall complexity =O(n)+O(1)=O(n)&lt;&lt; O(b)</p>
                                    </div>
                                </div>
                            </div>
                            </div>
                        </div>
                    </div>

                <!-- END ROW -->

                <!-- end container-fluid -->
            </div>
            <!-- end wrapper -->
        </div>

    </body>
    </html>
    